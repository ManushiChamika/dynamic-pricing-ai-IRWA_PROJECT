diff --git a/_staged_diff_summary.txt b/_staged_diff_summary.txt
new file mode 100644
index 0000000..738994f
--- /dev/null
+++ b/_staged_diff_summary.txt
@@ -0,0 +1,72 @@
+---
+# Diff of all staged changes (feat/ui-activity-feed vs last commit)
+
+# app/llm_client.py
+# - Added chat_with_tools: OpenAI-style tool-calling loop, executes Python functions for tool_calls, returns final assistant content.
+
+# app/pages/dashboard.py
+# - Migrated chat UI to support threads (multi-chat), thread selection, rename, and new chat creation in sidebar.
+# - User data persistence now stores threads, current_thread_id, and chat_history for backward compatibility.
+# - Agent is seeded from current thread's messages for persistent memory.
+# - Chat input/output writes to the current thread and keeps agent memory in sync.
+
+# core/agents/user_interact/user_interaction_agent.py
+# - Added SQLite-backed tools: list_inventory_items, get_inventory_item, list_pricing_list, list_price_proposals.
+# - get_response now uses chat_with_tools for OpenAI-style tool-calling, passing tool schemas and function map.
+# - DB paths resolved in __init__.
+
+# user_data.json
+# - User data migrated to threads-based schema for chat history, with per-thread messages and current_thread_id.
+# - Example threads and messages shown for two users.
+
+---
+
+# app/llm_client.py
+- Added chat_with_tools method to LLMClient, supporting OpenAI-style tool-calling with multi-round execution.
+- Handles tool_calls, executes mapped Python functions, and appends tool outputs as tool messages.
+- Returns final assistant content when no further tool_calls are present.
+
+# app/pages/dashboard.py
+- Chat UI now supports multiple threads (conversations) in the sidebar.
+- Users can select, rename, and create new chat threads.
+- User data is persisted as threads, current_thread_id, and metrics, with chat_history for backward compatibility.
+- Agent is seeded from the selected thread's messages for persistent memory.
+- Chat input/output writes to the current thread and keeps agent memory in sync.
+
+# core/agents/user_interact/user_interaction_agent.py
+- Added SQLite-backed tools for inventory and pricing:
+  - list_inventory_items: Lists items from app/data.db/product_catalog.
+  - get_inventory_item: Gets a single item by SKU.
+  - list_pricing_list: Lists entries from market.db/pricing_list.
+  - list_price_proposals: Lists recent price proposals from app/data.db/price_proposals.
+- get_response uses chat_with_tools, passing tool schemas and function map.
+- DB paths are resolved in __init__ for portability.
+
+# user_data.json
+- User data migrated to threads-based schema for chat history, with per-thread messages and current_thread_id.
+- Example threads and messages shown for two users, including inventory and pricing queries.
+
+---
+
+# Summary
+This commit introduces OpenAI-style tool-calling to the LLM agent, enabling the assistant to answer inventory and pricing queries using live data from SQLite databases. The chat UI is upgraded to support multiple threads (conversations), with per-thread persistence and backward compatibility. The agent is seeded from the selected thread's messages for persistent memory, and all chat input/output is thread-aware. User data is now stored in a threads-based schema, and the agent can answer factual queries about inventory and pricing using the new tool-calling path.
+
+# Details
+- LLMClient (app/llm_client.py) now supports chat_with_tools, a multi-round tool-calling loop compatible with OpenAI's function-calling API.
+- UserInteractionAgent (core/agents/user_interact/user_interaction_agent.py) defines SQLite-backed tools for inventory and pricing, and uses chat_with_tools to answer queries.
+- The dashboard (app/pages/dashboard.py) supports chat threads, thread management, and thread-aware persistence.
+- user_data.json is migrated to the new threads schema, with example data for two users.
+
+# Impact
+- The assistant can now answer queries like "What are the items I have?" or "Show competitor prices for iPhone 15" using live DB data.
+- Chat UI is more realistic and user-friendly, supporting multiple conversations per user.
+- All changes are backward compatible with previous user data.
+
+# Migration
+- Existing user_data.json is automatically migrated to the new threads schema on load.
+- No manual DB migration is required; tool functions handle missing tables gracefully.
+
+# Next Steps
+- Add more tools as needed (e.g., create_item, update_price) for richer agent capabilities.
+- Add tests for tool functions and agent responses.
+- Optional: UI polish and memory summarization for long threads.
diff --git a/app/llm_client.py b/app/llm_client.py
index 0ef01ec..5b073c9 100644
--- a/app/llm_client.py
+++ b/app/llm_client.py
@@ -13,7 +13,8 @@ import os
 import importlib
 import logging
 from pathlib import Path
-from typing import Optional, Any, Dict, List
+from typing import Optional, Any, Dict, List, Callable
+import json
 
 
 def _load_dotenv_if_present() -> None:
@@ -176,6 +177,115 @@ class LLMClient:
             self._log.error("LLM error: %s", e)
             raise RuntimeError(f"LLM error: {e}")
 
+    def chat_with_tools(
+        self,
+        messages: List[Dict[str, Any]],
+        tools: List[Dict[str, Any]],
+        functions_map: Dict[str, Callable[..., Any]],
+        tool_choice: Optional[str] = "auto",
+        max_rounds: int = 3,
+        max_tokens: int = 256,
+        temperature: float = 0.2,
+    ) -> str:
+        """OpenAI-style tool calling loop.
+
+        - Sends tools schema to the model.
+        - If the model returns tool_calls, executes mapped Python functions.
+        - Appends tool outputs as messages with role="tool" and continues.
+        - Returns final assistant content when no further tool_calls are present.
+        """
+        if not self._client:
+            raise RuntimeError("LLM client unavailable (missing key or package)")
+        local_msgs: List[Dict[str, Any]] = list(messages)
+        for round_i in range(max_rounds):
+            try:
+                self._log.debug(
+                    "Tool round %d | provider=%s model=%s msgs=%d tools=%d",
+                    round_i + 1, self._provider, self.model, len(local_msgs), len(tools)
+                )
+                resp = self._client.chat.completions.create(
+                    model=self.model,
+                    messages=local_msgs,
+                    tools=tools,
+                    **({"tool_choice": tool_choice} if tool_choice else {}),
+                    max_tokens=max_tokens,
+                    temperature=temperature,
+                )
+            except Exception as e:
+                # Provider/model may not support tools; surface error to caller
+                self._log.error("LLM tools error: %s", e)
+                raise RuntimeError(f"LLM tools error: {e}")
+
+            choice = resp.choices[0]
+            msg = choice.message
+            # Safely access properties across SDK variants
+            content = getattr(msg, "content", None)
+            tool_calls = getattr(msg, "tool_calls", None) or []
+
+            assistant_msg: Dict[str, Any] = {"role": "assistant"}
+            if content is not None:
+                assistant_msg["content"] = content
+            if tool_calls:
+                # Normalize tool_calls structure
+                normalized_calls = []
+                for tc in tool_calls:
+                    try:
+                        normalized_calls.append({
+                            "id": tc.id,
+                            "type": getattr(tc, "type", "function"),
+                            "function": {
+                                "name": tc.function.name,
+                                "arguments": tc.function.arguments,
+                            },
+                        })
+                    except Exception:
+                        # Fallback best-effort
+                        normalized_calls.append(json.loads(json.dumps(tc)))
+                assistant_msg["tool_calls"] = normalized_calls
+
+            local_msgs.append(assistant_msg)
+
+            if not tool_calls:
+                # Final content
+                return (content or "").strip()
+
+            # Execute tools and append their outputs
+            for tc in assistant_msg["tool_calls"]:
+                fn_name = tc.get("function", {}).get("name")
+                raw_args = tc.get("function", {}).get("arguments") or "{}"
+                call_id = tc.get("id") or "tool_call"
+                try:
+                    args = json.loads(raw_args) if isinstance(raw_args, str) else (raw_args or {})
+                except Exception:
+                    args = {}
+                result: Any
+                if fn_name in functions_map:
+                    try:
+                        result = functions_map[fn_name](**args)
+                    except TypeError:
+                        # In case function expects a dict
+                        result = functions_map[fn_name](args)
+                    except Exception as e:
+                        result = {"error": str(e)}
+                else:
+                    result = {"error": f"unknown tool: {fn_name}"}
+
+                # Ensure string content
+                try:
+                    content_str = result if isinstance(result, str) else json.dumps(result, ensure_ascii=False)
+                except Exception:
+                    content_str = str(result)
+
+                local_msgs.append({
+                    "role": "tool",
+                    "tool_call_id": call_id,
+                    "name": fn_name,
+                    "content": content_str,
+                })
+
+        # Safety: if max rounds exhausted, return whatever we have in last assistant content
+        return (assistant_msg.get("content") or "").strip()
+
 
 def get_llm_client() -> LLMClient:
     return LLMClient()
diff --git a/app/pages/dashboard.py b/app/pages/dashboard.py
index 037a325..3cee1ea 100644
--- a/app/pages/dashboard.py
+++ b/app/pages/dashboard.py
@@ -6,6 +6,7 @@ import os
 import json
 from datetime import datetime
 import asyncio
+import uuid
 import threading
 from concurrent.futures import TimeoutError as FuturesTimeout
 import sys
@@ -64,16 +65,61 @@ def get_demand_trend() -> pd.DataFrame:
 DATA_FILE = "user_data.json"
 
 def load_user_data(email: str):
+    """Load user data. Backward compatible with older schema that only had chat_history.
+
+    Returns a dict with keys:
+    - threads: {thread_id: {"title": str, "messages": [ {role, content, time} ] }}
+    - current_thread_id: str
+    - metrics: any
+    - chat_history: maintained for backward compatibility (current thread messages)
+    """
+    empty = {"threads": {}, "current_thread_id": None, "metrics": None, "chat_history": []}
     if os.path.exists(DATA_FILE):
         try:
             with open(DATA_FILE, "r") as f:
                 all_data = json.load(f)
-            return all_data.get(email, {"chat_history": [], "metrics": None})
+            user = all_data.get(email)
+            if not user:
+                return empty
+            # New schema present
+            if "threads" in user:
+                threads = user.get("threads", {}) or {}
+                current = user.get("current_thread_id")
+                if not threads:
+                    # Create an empty default thread
+                    tid = str(uuid.uuid4())
+                    threads = {tid: {"title": "New chat", "messages": []}}
+                    current = tid
+                if not current or current not in threads:
+                    current = next(iter(threads.keys()))
+                # Back-compat mirror
+                ch = threads[current]["messages"]
+                return {
+                    "threads": threads,
+                    "current_thread_id": current,
+                    "metrics": user.get("metrics"),
+                    "chat_history": ch,
+                }
+            # Old schema: migrate one linear chat_history into a default thread
+            old_ch = user.get("chat_history", []) or []
+            tid = str(uuid.uuid4())
+            threads = {tid: {"title": "Chat 1", "messages": old_ch}}
+            return {
+                "threads": threads,
+                "current_thread_id": tid,
+                "metrics": user.get("metrics"),
+                "chat_history": old_ch,
+            }
         except json.JSONDecodeError:
-            return {"chat_history": [], "metrics": None}
-    return {"chat_history": [], "metrics": None}
+            return empty
+    return empty
 
 def save_user_data(email: str, data: dict):
+    """Save user data with backward compatibility.
+
+    Expects keys in data: threads, current_thread_id, metrics.
+    Also stores chat_history mirror of the current thread for older readers.
+    """
     all_data = {}
     if os.path.exists(DATA_FILE):
         try:
@@ -81,7 +127,26 @@ def save_user_data(email: str, data: dict):
                 all_data = json.load(f)
         except json.JSONDecodeError:
             all_data = {}
-    all_data[email] = data
+
+    threads = data.get("threads") or {}
+    current = data.get("current_thread_id")
+    if not threads:
+        tid = str(uuid.uuid4())
+        threads = {tid: {"title": "New chat", "messages": []}}
+        current = tid
+    if not current or current not in threads:
+        current = next(iter(threads.keys()))
+
+    current_messages = threads[current]["messages"]
+    payload = {
+        "threads": threads,
+        "current_thread_id": current,
+        "metrics": data.get("metrics"),
+        # Back-compat mirror
+        "chat_history": current_messages,
+    }
+
+    all_data[email] = payload
     with open(DATA_FILE, "w") as f:
         json.dump(all_data, f, indent=4)
 
@@ -104,14 +169,40 @@ else:
     user_name = user_email.split("@")[0]
 
 
-# Load persisted user data into session_state once
-if "chat_history" not in st.session_state or "metrics" not in st.session_state:
+# Load persisted user data into session_state once (threads-aware)
+if any(k not in st.session_state for k in ("threads", "current_thread_id", "metrics")):
     _loaded = load_user_data(user_email)
-    st.session_state.setdefault("chat_history", _loaded.get("chat_history", []))
+    st.session_state.setdefault("threads", _loaded.get("threads", {}))
+    st.session_state.setdefault("current_thread_id", _loaded.get("current_thread_id"))
     st.session_state.setdefault("metrics", _loaded.get("metrics", None))
-
-# Initialize OpenRouter-based agent
-agent = UserInteractionAgent(user_name=user_name)
+    # Backward-compat mirror of current thread
+    cur = st.session_state.get("current_thread_id")
+    cur_msgs = []
+    if cur and cur in st.session_state["threads"]:
+        cur_msgs = st.session_state["threads"][cur]["messages"]
+    st.session_state.setdefault("chat_history", cur_msgs)
+
+# Initialize agent once per user session and seed with prior chat history
+AGENT_KEY = "agent"
+AGENT_USER_KEY = "agent_user_email"
+if (
+    AGENT_KEY not in st.session_state
+    or st.session_state.get(AGENT_USER_KEY) != user_email
+):
+    agent = UserInteractionAgent(user_name=user_name)
+    # Seed agent memory from persisted chat history so LLM sees full context
+    for msg in st.session_state.get("chat_history", []):
+        role = msg.get("role")
+        content = msg.get("content")
+        if role in ("user", "assistant") and isinstance(content, str):
+            try:
+                agent.add_to_memory(role, content)
+            except Exception:
+                pass
+    st.session_state[AGENT_KEY] = agent
+    st.session_state[AGENT_USER_KEY] = user_email
+else:
+    agent = st.session_state[AGENT_KEY]
 
 # ===================
 # Dashboard Header/UI
@@ -142,8 +233,9 @@ st.markdown("---")
 
 # Persist metrics
 save_user_data(user_email, {
-    "chat_history": st.session_state["chat_history"],
-    "metrics": st.session_state["metrics"]
+    "threads": st.session_state.get("threads", {}),
+    "current_thread_id": st.session_state.get("current_thread_id"),
+    "metrics": st.session_state["metrics"],
 })
 
 # ---- Charts ----
@@ -170,9 +262,52 @@ st.sidebar.subheader("ðŸ‘¤ User Info")
 st.sidebar.info(f"Name: {user_name}\n*Email:* {user_email}")
 
 # Chat history
-st.sidebar.subheader("ðŸ’¬ Chat History")
+st.sidebar.subheader("ðŸ’¬ Chats")
+# Thread selection and management
+threads = st.session_state.get("threads", {})
+current_thread_id = st.session_state.get("current_thread_id")
+if not threads:
+    # Ensure at least one thread exists
+    tid = str(uuid.uuid4())
+    threads[tid] = {"title": "New chat", "messages": []}
+    st.session_state["threads"] = threads
+    st.session_state["current_thread_id"] = tid
+    current_thread_id = tid
+
+# Dropdown to pick thread
+options = [(tid, data.get("title") or f"Chat {i+1}") for i, (tid, data) in enumerate(threads.items())]
+labels = {tid: title for tid, title in options}
+tid_list = [tid for tid, _ in options]
+if current_thread_id not in threads:
+    current_thread_id = tid_list[0]
+selected = st.sidebar.selectbox(
+    "Select conversation",
+    options=tid_list,
+    index=tid_list.index(current_thread_id),
+    format_func=lambda tid: labels.get(tid, tid),
+)
+if selected != current_thread_id:
+    st.session_state["current_thread_id"] = selected
+    # Mirror chat_history for back-compat
+    st.session_state["chat_history"] = st.session_state["threads"][selected]["messages"]
+
+with st.sidebar.expander("Manage chats", expanded=False):
+    c1, c2 = st.columns([2, 1])
+    with c1:
+        new_title = st.text_input("Rename current", value=labels.get(selected, ""), key="rename_thread")
+    with c2:
+        if st.button("Save", key="rename_thread_btn"):
+            st.session_state["threads"][selected]["title"] = new_title or labels.get(selected)
+    if st.button("New chat", key="new_thread_btn"):
+        tid = str(uuid.uuid4())
+        st.session_state["threads"][tid] = {"title": f"Chat {len(threads)+1}", "messages": []}
+        st.session_state["current_thread_id"] = tid
+        st.session_state["chat_history"] = []
+
+st.sidebar.markdown("---")
+st.sidebar.subheader("ðŸ—¨ï¸ Messages")
 chat_container = st.sidebar.container()
-for chat in st.session_state.chat_history:
+for chat in st.session_state.get("threads", {}).get(st.session_state.get("current_thread_id"), {}).get("messages", []):
     role = chat.get("role")
     message = chat.get("content")
     time_str = chat.get("time", datetime.now().strftime("%H:%M:%S"))
@@ -184,27 +319,51 @@ for chat in st.session_state.chat_history:
 # Chat input + response
 user_input = st.chat_input("Ask me about pricing, demand, or sales...")
 if user_input:
-    st.session_state["chat_history"].append({
+    msg_user = {
         "role": "user",
         "content": user_input,
         "time": datetime.now().strftime("%H:%M:%S")
-    })
+    }
+    # Write to current thread + mirror
+    cur = st.session_state.get("current_thread_id")
+    if cur and cur in st.session_state["threads"]:
+        st.session_state["threads"][cur]["messages"].append(msg_user)
+        st.session_state["chat_history"] = st.session_state["threads"][cur]["messages"]
+    else:
+        st.session_state["chat_history"].append(msg_user)
+    # Keep agent memory in sync for immediate context
+    try:
+        agent.add_to_memory("user", user_input)
+    except Exception:
+        pass
     with st.chat_message("user"):
         st.markdown(user_input)
 
     # Call OpenRouter agent
     response = agent.get_response(user_input)
-    st.session_state["chat_history"].append({
+    msg_bot = {
         "role": "assistant",
         "content": response,
         "time": datetime.now().strftime("%H:%M:%S")
-    })
+    }
+    # Write to current thread + mirror
+    cur = st.session_state.get("current_thread_id")
+    if cur and cur in st.session_state["threads"]:
+        st.session_state["threads"][cur]["messages"].append(msg_bot)
+        st.session_state["chat_history"] = st.session_state["threads"][cur]["messages"]
+    else:
+        st.session_state["chat_history"].append(msg_bot)
+    try:
+        agent.add_to_memory("assistant", response)
+    except Exception:
+        pass
     with st.chat_message("assistant"):
         st.markdown(response)
 
     save_user_data(user_email, {
-        "chat_history": st.session_state["chat_history"],
-        "metrics": st.session_state["metrics"]
+        "threads": st.session_state.get("threads", {}),
+        "current_thread_id": st.session_state.get("current_thread_id"),
+        "metrics": st.session_state["metrics"],
     })
 
 # Logout
diff --git a/core/agents/user_interact/user_interaction_agent.py b/core/agents/user_interact/user_interaction_agent.py
index 8870e87..1464e9f 100644
--- a/core/agents/user_interact/user_interaction_agent.py
+++ b/core/agents/user_interact/user_interaction_agent.py
@@ -1,6 +1,9 @@
 import os
+import sqlite3
+from pathlib import Path
 import requests
 from dotenv import load_dotenv
+from typing import Any, Dict, List, Optional
 
 # Load .env variables
 load_dotenv()
@@ -23,6 +26,10 @@ class UserInteractionAgent:
         ]
         # Memory to store conversation history
         self.memory = []
+        # Resolve DB paths
+        root = Path(__file__).resolve().parents[3]
+        self.app_db = root / "app" / "data.db"
+        self.market_db = root / "market.db"
 
     def is_dynamic_pricing_related(self, message):
         message_lower = message.lower()
@@ -39,7 +46,6 @@ class UserInteractionAgent:
         - If an LLM client is available, forward the message (with memory/system prompt) and return the model answer.
         - If LLM is not available, keep the original keyword guard but return an explicit non-LLM fallback message so callers know it's not the LLM speaking.
         """
-
         # Add user message to memory
         self.add_to_memory("user", message)
 
@@ -56,14 +62,177 @@ class UserInteractionAgent:
                 llm = get_llm_client()
                 if llm.is_available():
                     msgs = [{"role": "system", "content": system_prompt}]
+                    # self.memory already includes the latest user message added above
                     msgs.extend(self.memory)
-                    msgs.append({"role": "user", "content": message})
+
+                    # Define tools (OpenAI schema)
+                    tools = [
+                        {
+                            "type": "function",
+                            "function": {
+                                "name": "list_inventory_items",
+                                "description": "List items from the local product catalog (app/data.db). Use for inventory overviews.",
+                                "parameters": {
+                                    "type": "object",
+                                    "properties": {
+                                        "search": {"type": "string", "description": "Filter by substring in SKU or title."},
+                                        "limit": {"type": "integer", "minimum": 1, "maximum": 200, "default": 50},
+                                    },
+                                    "additionalProperties": False,
+                                },
+                            },
+                        },
+                        {
+                            "type": "function",
+                            "function": {
+                                "name": "get_inventory_item",
+                                "description": "Get a single inventory item by SKU from app/data.db/product_catalog.",
+                                "parameters": {
+                                    "type": "object",
+                                    "properties": {
+                                        "sku": {"type": "string", "description": "Item SKU (exact match)"},
+                                    },
+                                    "required": ["sku"],
+                                    "additionalProperties": False,
+                                },
+                            },
+                        },
+                        {
+                            "type": "function",
+                            "function": {
+                                "name": "list_pricing_list",
+                                "description": "List current market pricing entries from market.db/pricing_list.",
+                                "parameters": {
+                                    "type": "object",
+                                    "properties": {
+                                        "search": {"type": "string", "description": "Filter by substring in product_name."},
+                                        "limit": {"type": "integer", "minimum": 1, "maximum": 200, "default": 50},
+                                    },
+                                    "additionalProperties": False,
+                                },
+                            },
+                        },
+                        {
+                            "type": "function",
+                            "function": {
+                                "name": "list_price_proposals",
+                                "description": "List recent price proposals from app/data.db/price_proposals.",
+                                "parameters": {
+                                    "type": "object",
+                                    "properties": {
+                                        "sku": {"type": "string", "description": "Optional filter by SKU"},
+                                        "limit": {"type": "integer", "minimum": 1, "maximum": 200, "default": 50},
+                                    },
+                                    "additionalProperties": False,
+                                },
+                            },
+                        },
+                    ]
+
+                    # Python implementations
+                    def _table_exists(conn: sqlite3.Connection, table: str) -> bool:
+                        try:
+                            cur = conn.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table,))
+                            return cur.fetchone() is not None
+                        except Exception:
+                            return False
+
+                    def list_inventory_items(search: Optional[str] = None, limit: int = 50) -> Dict[str, Any]:
+                        db_path = str(self.app_db)
+                        try:
+                            with sqlite3.connect(db_path) as conn:
+                                conn.row_factory = sqlite3.Row
+                                if not _table_exists(conn, "product_catalog"):
+                                    return {"items": [], "total": 0, "note": "product_catalog missing"}
+                                q = "SELECT sku, title, currency, current_price, cost, stock, updated_at FROM product_catalog"
+                                params: List[Any] = []
+                                if search:
+                                    q += " WHERE sku LIKE ? OR title LIKE ?"
+                                    like = f"%{search}%"
+                                    params.extend([like, like])
+                                q += " ORDER BY updated_at DESC LIMIT ?"
+                                params.append(int(limit))
+                                rows = [dict(r) for r in conn.execute(q, params).fetchall()]
+                                return {"items": rows, "total": len(rows)}
+                        except Exception as e:
+                            return {"error": str(e)}
+
+                    def get_inventory_item(sku: str) -> Dict[str, Any]:
+                        db_path = str(self.app_db)
+                        try:
+                            with sqlite3.connect(db_path) as conn:
+                                conn.row_factory = sqlite3.Row
+                                if not _table_exists(conn, "product_catalog"):
+                                    return {"item": None, "note": "product_catalog missing"}
+                                row = conn.execute(
+                                    "SELECT sku, title, currency, current_price, cost, stock, updated_at FROM product_catalog WHERE sku=? LIMIT 1",
+                                    (sku,),
+                                ).fetchone()
+                                return {"item": dict(row) if row else None}
+                        except Exception as e:
+                            return {"error": str(e)}
+
+                    def list_pricing_list(search: Optional[str] = None, limit: int = 50) -> Dict[str, Any]:
+                        db_path = str(self.market_db)
+                        try:
+                            with sqlite3.connect(db_path) as conn:
+                                conn.row_factory = sqlite3.Row
+                                if not _table_exists(conn, "pricing_list"):
+                                    return {"items": [], "total": 0, "note": "pricing_list missing"}
+                                q = "SELECT product_name, optimized_price, last_update, reason FROM pricing_list"
+                                params: List[Any] = []
+                                if search:
+                                    q += " WHERE product_name LIKE ?"
+                                    params.append(f"%{search}%")
+                                q += " ORDER BY last_update DESC LIMIT ?"
+                                params.append(int(limit))
+                                rows = [dict(r) for r in conn.execute(q, params).fetchall()]
+                                return {"items": rows, "total": len(rows)}
+                        except Exception as e:
+                            return {"error": str(e)}
+
+                    def list_price_proposals(sku: Optional[str] = None, limit: int = 50) -> Dict[str, Any]:
+                        db_path = str(self.app_db)
+                        try:
+                            with sqlite3.connect(db_path) as conn:
+                                conn.row_factory = sqlite3.Row
+                                if not _table_exists(conn, "price_proposals"):
+                                    return {"items": [], "total": 0, "note": "price_proposals missing"}
+                                q = (
+                                    "SELECT id, sku, proposed_price, current_price, margin, algorithm, ts FROM price_proposals"
+                                )
+                                params: List[Any] = []
+                                if sku:
+                                    q += " WHERE sku = ?"
+                                    params.append(sku)
+                                q += " ORDER BY ts DESC LIMIT ?"
+                                params.append(int(limit))
+                                rows = [dict(r) for r in conn.execute(q, params).fetchall()]
+                                return {"items": rows, "total": len(rows)}
+                        except Exception as e:
+                            return {"error": str(e)}
+
+                    functions_map = {
+                        "list_inventory_items": list_inventory_items,
+                        "get_inventory_item": get_inventory_item,
+                        "list_pricing_list": list_pricing_list,
+                        "list_price_proposals": list_price_proposals,
+                    }
+
                     try:
-                        answer = llm.chat(msgs)
+                        answer = llm.chat_with_tools(
+                            messages=msgs,
+                            tools=tools,
+                            functions_map=functions_map,
+                            tool_choice="auto",
+                            max_rounds=4,
+                            max_tokens=384,
+                            temperature=0.2,
+                        )
                         # Add assistant reply to memory
                         self.add_to_memory("assistant", answer)
                         return answer
-                    except Exception as e:
+                    except Exception:
                         # Fall through to explicit non-LLM fallback
                         pass
 
@@ -83,8 +252,8 @@ class UserInteractionAgent:
             }
 
             messages = [{"role": "system", "content": system_prompt}]
+            # self.memory already includes the latest user message added above
             messages.extend(self.memory)
-            messages.append({"role": "user", "content": message})
 
             data = {
                 "model": self.model_name,
diff --git a/user_data.json b/user_data.json
index 2fe0a08..997ff60 100644
--- a/user_data.json
+++ b/user_data.json
@@ -8,162 +8,305 @@
         }
     },
     "sasindu@gmail.com": {
-        "chat_history": [
-            {
-                "role": "user",
-                "content": "test 01",
-                "time": "17:33:36"
-            },
-            {
-                "role": "assistant",
-                "content": "I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "17:33:36"
-            },
-            {
-                "role": "user",
-                "content": "hello",
-                "time": "17:33:43"
-            },
-            {
-                "role": "assistant",
-                "content": "I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "17:33:43"
-            },
-            {
-                "role": "user",
-                "content": "ai you ai",
-                "time": "17:34:12"
-            },
-            {
-                "role": "assistant",
-                "content": "I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "17:34:12"
-            },
-            {
-                "role": "user",
-                "content": "ejbkawjg",
-                "time": "17:49:24"
-            },
-            {
-                "role": "assistant",
-                "content": "I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "17:49:24"
-            },
-            {
-                "role": "user",
-                "content": "eGG",
-                "time": "17:49:39"
-            },
-            {
-                "role": "assistant",
-                "content": "I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "17:49:39"
-            },
-            {
-                "role": "user",
-                "content": "jnfs",
-                "time": "17:50:14"
-            },
-            {
-                "role": "assistant",
-                "content": "I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "17:50:14"
-            },
-            {
-                "role": "user",
-                "content": "tesh",
-                "time": "01:51:14"
-            },
-            {
-                "role": "assistant",
-                "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "01:51:14"
-            },
-            {
-                "role": "user",
-                "content": "asrhjjtkd",
-                "time": "01:53:39"
-            },
-            {
-                "role": "assistant",
-                "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "01:53:39"
-            },
-            {
-                "role": "user",
-                "content": "zdsfjdk",
-                "time": "01:54:57"
-            },
-            {
-                "role": "assistant",
-                "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "01:54:57"
-            },
-            {
-                "role": "user",
-                "content": "sfhjdkfylug",
-                "time": "01:55:35"
-            },
-            {
-                "role": "assistant",
-                "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "01:55:35"
-            },
-            {
-                "role": "user",
-                "content": "sfhdgj",
-                "time": "01:56:22"
-            },
-            {
-                "role": "assistant",
-                "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "01:56:22"
-            },
-            {
-                "role": "user",
-                "content": "egHRW",
-                "time": "01:56:59"
-            },
-            {
-                "role": "assistant",
-                "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "01:56:59"
+        "threads": {
+            "c32139fe-b3fe-4e78-9019-ffd30b2aab73": {
+                "title": "Chat 1",
+                "messages": [
+                    {
+                        "role": "user",
+                        "content": "test 01",
+                        "time": "17:33:36"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "17:33:36"
+                    },
+                    {
+                        "role": "user",
+                        "content": "hello",
+                        "time": "17:33:43"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "17:33:43"
+                    },
+                    {
+                        "role": "user",
+                        "content": "ai you ai",
+                        "time": "17:34:12"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "17:34:12"
+                    },
+                    {
+                        "role": "user",
+                        "content": "ejbkawjg",
+                        "time": "17:49:24"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "17:49:24"
+                    },
+                    {
+                        "role": "user",
+                        "content": "eGG",
+                        "time": "17:49:39"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "17:49:39"
+                    },
+                    {
+                        "role": "user",
+                        "content": "jnfs",
+                        "time": "17:50:14"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "17:50:14"
+                    },
+                    {
+                        "role": "user",
+                        "content": "tesh",
+                        "time": "01:51:14"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "01:51:14"
+                    },
+                    {
+                        "role": "user",
+                        "content": "asrhjjtkd",
+                        "time": "01:53:39"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "01:53:39"
+                    },
+                    {
+                        "role": "user",
+                        "content": "zdsfjdk",
+                        "time": "01:54:57"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "01:54:57"
+                    },
+                    {
+                        "role": "user",
+                        "content": "sfhjdkfylug",
+                        "time": "01:55:35"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "01:55:35"
+                    },
+                    {
+                        "role": "user",
+                        "content": "sfhdgj",
+                        "time": "01:56:22"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "01:56:22"
+                    },
+                    {
+                        "role": "user",
+                        "content": "egHRW",
+                        "time": "01:56:59"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "01:56:59"
+                    },
+                    {
+                        "role": "user",
+                        "content": "ZDB",
+                        "time": "01:57:44"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
+                        "time": "01:57:44"
+                    },
+                    {
+                        "role": "user",
+                        "content": "esrydtjf",
+                        "time": "02:02:28"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I notice your message appears to contain random characters. As a specialized assistant for dynamic pricing systems, I can only provide responses related to pricing strategies, discounts, offers, demand/supply, and related financial metrics.\n\nDo you have a question about any of these topics? I'd be happy to help with pricing optimization, discount structures, or other financial aspects of your business.",
+                        "time": "02:02:52"
+                    },
+                    {
+                        "role": "user",
+                        "content": "\"What is the competitor price for iPhone 15 on https://smartmobile.lk/apple-iphone-price-list-in-sri-lanka/apple-iphone-16-plus-128gb Please optimize our price for maximum profit.\"",
+                        "time": "13:54:26"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "",
+                        "time": "13:54:39"
+                    },
+                    {
+                        "role": "user",
+                        "content": "ayo dana help me optimize iphone pricing ",
+                        "time": "23:08:11"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "",
+                        "time": "23:08:21"
+                    },
+                    {
+                        "role": "user",
+                        "content": "nothing is happening why",
+                        "time": "23:08:56"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I'm a specialized assistant for dynamic pricing systems. I can only provide information about pricing strategies, discounts, offers, demand/supply, and related financial metrics. \n\nDo you have any questions about these topics? For example, I can help with:\n- Setting optimal prices based on demand\n- Implementing discount strategies\n- Analyzing price elasticity\n- Managing inventory through pricing\n- Calculating profit margins\n- Competitive pricing analysis\n\nWhat specific pricing challenge can I help you with today?",
+                        "time": "23:09:04"
+                    },
+                    {
+                        "role": "user",
+                        "content": "what are the items i have",
+                        "time": "23:09:31"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I don't have access to your inventory or item information. As a dynamic pricing assistant, I can help you with pricing strategies, discounts, offers, demand/supply analysis, and related financial metrics, but I need you to provide details about the items you're working with.\n\nCould you please share information about the items you want help pricing, such as:\n- Product descriptions\n- Current pricing\n- Historical sales data\n- Market conditions\n- Competitor pricing\n- Any specific pricing challenges you're facing\n\nThis will allow me to provide more targeted assistance with your pricing strategy.",
+                        "time": "23:09:40"
+                    },
+                    {
+                        "role": "user",
+                        "content": "what is the price of iphone 15 in our store ",
+                        "time": "01:14:14"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I don't have access to your specific store's pricing data for the iPhone 15. The price can vary based on several factors including storage capacity, model (iPhone 15, 15 Plus, 15 Pro, or 15 Pro Max), carrier agreements, and current promotions.\n\nIf you'd like to discuss pricing strategies for the iPhone 15 in your store, I can help analyze factors like:\n- Competitor pricing in your area\n- Demand patterns for iPhone models\n- Optimal discount strategies\n- Bundle",
+                        "time": "01:14:25"
+                    },
+                    {
+                        "role": "user",
+                        "content": "do this \n\n\"Competitor pricing in your area\"",
+                        "time": "01:14:49"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "# Competitor Pricing Analysis\n\nUnderstanding competitor pricing in your market is essential for developing an effective pricing strategy. Here's how to approach it:\n\n## Key Considerations:\n- **Direct vs. Indirect Competitors**: Identify both businesses offering identical products/services and those serving similar customer needs\n- **Price Positioning**: Where do your prices fall relative to competitors (premium, mid-range, budget)?\n- **Price Differentiation**: What justifies price differences (quality, features, brand value)?",
+                        "time": "01:15:21"
+                    },
+                    {
+                        "role": "user",
+                        "content": "what are the items we have",
+                        "time": "05:29:46"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I don't have access to your specific inventory or product catalog. As a dynamic pricing assistant, I would need you to provide me with information about your items to help with pricing strategies.\n\nIf you'd like assistance with pricing, please share details such as:\n- Your product list or inventory items\n- Current pricing for each item\n- Cost of goods for each product\n- Historical sales data if available\n- Market conditions or seasonal factors\n\nOnce you provide this information, I can help you with pricing optimization strategies, discount structures, and other pricing-related decisions to maximize your profit margins.",
+                        "time": "05:30:04"
+                    },
+                    {
+                        "role": "user",
+                        "content": "what are the items i have ",
+                        "time": "10:18:49"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "Based on your inventory, you currently have **1 item**:\n\n**Item Details:**\n- **SKU:** SKU-123\n- **Title:** Demo\n- **Current Price:** $100.00 USD\n- **Cost:** $80.00 USD\n- **Stock Quantity:** 10 units\n- **Last Updated:** August 30, 2025\n\nThis appears to be a demo product with a profit margin of $20.00 per unit (20% margin).",
+                        "time": "10:19:11"
+                    }
+                ]
             },
+            "29e073fa-4440-48d6-b002-34e8878ee36b": {
+                "title": "Chat 2",
+                "messages": [
+                    {
+                        "role": "user",
+                        "content": "what are the items we have ",
+                        "time": "10:19:57"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "Based on your inventory, you currently have **1 item**:\n\n**Item Details:**\n- **SKU:** SKU-123\n- **Title:** Demo\n- **Current Price:** $100.00 USD\n- **Cost:** $80.00 USD\n- **Stock Quantity:** 10 units\n- **Last Updated:** August 30, 2025\n\nThis appears to be a demo product with a profit margin of $20.00 per unit (20% margin).",
+                        "time": "10:20:11"
+                    },
+                    {
+                        "role": "user",
+                        "content": "what are the competitor prices for that ",
+                        "time": "10:20:29"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "Based on the search results, there are no competitor pricing entries available for the \"Demo\" item (SKU: SKU-123) in your system.\n\nThe pricing list shows:\n- Your \"Demo\" item: $100.00 current price\n- No competitor pricing data found for this specific item\n\nIf you're looking for competitor pricing for other items, I can search the pricing list. For example, I found one entry for \"iphone15\" with an optimized price of $1291.45, but this appears to be a different product than your \"Demo\" item.\n\nWould you like me to search for competitor pricing for a different product, or do you have other items you'd like me to check?",
+                        "time": "10:21:01"
+                    },
+                    {
+                        "role": "user",
+                        "content": "can you create a new item called i phone 15 156 gb ",
+                        "time": "10:21:33"
+                    },
+                    {
+                        "role": "assistant",
+                        "content": "I don't have the capability to create new items in the inventory system with the available tools. The functions I have access to only allow me to:\n\n- List existing inventory items\n- Get details of existing items by SKU\n- View current market pricing\n- View price proposals\n\nTo create a new item called \"i phone 15 156 gb\", you would need to:\n\n1. Add it to your product catalog/database directly through your inventory management system\n2. Then I can help you with pricing analysis, competitor pricing, and optimization once the item exists in your system\n\nWould you like me to help you with anything else related to your existing inventory items, such as:\n- Finding competitor pricing for existing items\n- Analyzing current pricing strategies\n- Optimizing prices for maximum profit on existing products?",
+                        "time": "10:21:45"
+                    }
+                ]
+            }
+        },
+        "current_thread_id": "29e073fa-4440-48d6-b002-34e8878ee36b",
+        "metrics": {
+            "total_sales": 275732,
+            "avg_price": 160.6,
+            "units_sold": 1697
+        },
+        "chat_history": [
             {
                 "role": "user",
-                "content": "ZDB",
-                "time": "01:57:44"
+                "content": "what are the items we have ",
+                "time": "10:19:57"
             },
             {
                 "role": "assistant",
-                "content": "[non-LLM assistant] I'm only able to respond to queries related to the dynamic pricing system.",
-                "time": "01:57:44"
+                "content": "Based on your inventory, you currently have **1 item**:\n\n**Item Details:**\n- **SKU:** SKU-123\n- **Title:** Demo\n- **Current Price:** $100.00 USD\n- **Cost:** $80.00 USD\n- **Stock Quantity:** 10 units\n- **Last Updated:** August 30, 2025\n\nThis appears to be a demo product with a profit margin of $20.00 per unit (20% margin).",
+                "time": "10:20:11"
             },
             {
                 "role": "user",
-                "content": "esrydtjf",
-                "time": "02:02:28"
+                "content": "what are the competitor prices for that ",
+                "time": "10:20:29"
             },
             {
                 "role": "assistant",
-                "content": "I notice your message appears to contain random characters. As a specialized assistant for dynamic pricing systems, I can only provide responses related to pricing strategies, discounts, offers, demand/supply, and related financial metrics.\n\nDo you have a question about any of these topics? I'd be happy to help with pricing optimization, discount structures, or other financial aspects of your business.",
-                "time": "02:02:52"
+                "content": "Based on the search results, there are no competitor pricing entries available for the \"Demo\" item (SKU: SKU-123) in your system.\n\nThe pricing list shows:\n- Your \"Demo\" item: $100.00 current price\n- No competitor pricing data found for this specific item\n\nIf you're looking for competitor pricing for other items, I can search the pricing list. For example, I found one entry for \"iphone15\" with an optimized price of $1291.45, but this appears to be a different product than your \"Demo\" item.\n\nWould you like me to search for competitor pricing for a different product, or do you have other items you'd like me to check?",
+                "time": "10:21:01"
             },
             {
                 "role": "user",
-                "content": "\"What is the competitor price for iPhone 15 on https://smartmobile.lk/apple-iphone-price-list-in-sri-lanka/apple-iphone-16-plus-128gb Please optimize our price for maximum profit.\"",
-                "time": "13:54:26"
+                "content": "can you create a new item called i phone 15 156 gb ",
+                "time": "10:21:33"
             },
             {
                 "role": "assistant",
-                "content": "",
-                "time": "13:54:39"
+                "content": "I don't have the capability to create new items in the inventory system with the available tools. The functions I have access to only allow me to:\n\n- List existing inventory items\n- Get details of existing items by SKU\n- View current market pricing\n- View price proposals\n\nTo create a new item called \"i phone 15 156 gb\", you would need to:\n\n1. Add it to your product catalog/database directly through your inventory management system\n2. Then I can help you with pricing analysis, competitor pricing, and optimization once the item exists in your system\n\nWould you like me to help you with anything else related to your existing inventory items, such as:\n- Finding competitor pricing for existing items\n- Analyzing current pricing strategies\n- Optimizing prices for maximum profit on existing products?",
+                "time": "10:21:45"
             }
-        ],
-        "metrics": {
-            "total_sales": 275732,
-            "avg_price": 160.6,
-            "units_sold": 1697
-        }
+        ]
     }
 }
\ No newline at end of file
